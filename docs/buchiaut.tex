\documentclass[runningheads, envcountsame]{llncs}

\usepackage{mysty}
%\usepackage{myspacehack}

\newcommand{\uli}[1]{}
\newcommand{\sv}[1]{}
\newcommand{\psc}[1]{}
\newcommand{\rs}[1]{}
\usepackage{mydraft}
\usepackage[pdf]{graphviz}

\begin{document}

\title{Internship FAQ}
\author{Rania Saadi}
% \authorrunning{Dziadek, Fahrenberg, Schlehuber}
\institute{EPITA Research Laboratory (LRE), France}

\maketitle

%\vspace*{-1cm}
get_entering_states
the graph, spot scc info, scc index
all the entering states by number without the looping edges

degen_counting
the graph, spot scc info, scc index
tuple : the degeneralized graph, backedges, dictionary original_graph/SCC
- creates the rename() dictionary, index in original graph, index in scc
- retrieves the number of states
- gets the maximum acceptance set index (the number of colors?)
- copies the automata, adds just one Bushi condition
- creates “number of colors (so levels?) * number of states” states
- for each edge in SCC, then for each color :

    creates an edge between (color (level) * states + local source) and (color (level) * states + local destination) and mark the edge if the next color is 0

    all marked edges are added to backedges (don’t we just need one?)

    set the first entering state encountered to the starting state of the new graph



prop_

the graph, the edge number, optimal energy is chosen or propagated (opt)

propagates energy along the edge, returns whether destination changed or not

- e’ = calculates bounded energy min(weak upper bound, state energy + weight)

- if e’ is positive and higher then destination energy update destination energy to e’ and add the edge to optimal predecessors

- if e’ is positive and opt is false update destination energy to e’ and add the edge to optimal predecessors (just using the weights when running pump and using the weak upper bound when running BF1)

- return true if energy destination changes, false otherwise



mark_

tha graph, the state

marks a state as waiting if it’s not already waiting and adds it to the list of waiting states



loop_

the graph, the initial state

iterates over loops starting from the initial state and returns its contents

_rotate(1) is used to bring the initial state to the start



pumpLoop_

the graph, the state

pumps a positive loop containing the state

- sets all the states’ energy on the loop to -2 (special marker? why -2)

- maks all the states with 2 (mark for an old loop)

- pumps the initial state with the weak upper bound

- sets a counter for iterations, launches loop_ on each state until unchangrd (reached the fixed point)

- if the counter is higher then 2, it reached the fixed point too late

% \bibliographystyle{plain}
% \bibliography{bib}

\end{document}
