\documentclass{rapport}
\usepackage{lipsum}
\usepackage{underscore}
\usepackage{xcolor}
\title{Rapport UCL - Template} %Titre du fichier

\newcommand{\pscrep}[1]{\textcolor{green}{#1}}

\begin{document}

%----------- Informations du rapport ---------

\logo{logos/logo_lre.png}
\unif{EPITA Research Laboratory (LRE), France}
\titre{Internship FAQ} %Titre du fichier .pdf
\cours{Rania Saadi} %Nom du cours
\sujet{Energy Büchi Problems} %Nom du sujet



%----------- Initialisation -------------------

\fairemarges %Afficher les marges
\fairepagedegarde %Créer la page de garde
\tabledematieres %Créer la table de matières

%------------ Corps du rapport ----------------


\section{The functions}

\textcolor{blue}{get_entering_states} \\
\textcolor[HTML]{006400}{the graph, spot SCC info, SCC index} \\
\textcolor{brown}{all the entering states by number without the looping edges} \\
\pscrep{I'm not sure what you mean, in any case, the entering states
are the states of an scc which can be attained from another SCC.
So if $S$ is a state in SCC $X$, then there is a transition $Sp\rightarrow S$
with $Sp$ being part of the SCC $Xp \neq X$.}

\textcolor{blue}{degen_counting}\\
\textcolor[HTML]{006400}{the graph, spot SCC info, SCC index}\\
\textcolor{brown}{tuple : the degeneralized graph, backedges, dictionary original_graph/SCC}
\begin{itemize}
    \item creates the rename() dictionary, index in the original graph, index in SCC
    \item retrieves the number of states
    \item gets the maximum acceptance set index \textcolor{red}{(number of colors?)} \pscrep{Yes}
    \item copies the automata, adds just one Buchi condition \pscrep{Buchi cond -> one color; Generalized Buchi cond -> multiple colors}
    \item creates "number of colors \textcolor{red}{(so levels?)} * number of states" states \pscrep{Yes, one level per color, order is arbitrary}
    \item for each edge in SCC, then for each color :
    \begin{itemize}
        \item creates an edge between (color (level) * states + local source) and (color (level) * states + local destination) and marks the edge if the next color is 0
        \item all marked edges are added to backedges \textcolor{red}{(don’t we just need one?)}
        \item sets the first entering state encountered to the starting state of the new graph
    \end{itemize}
    \pscrep{Here I'm not sure, I'll rephase}
    \begin{itemize}
        \item Make a large automaton with original number of states times number of original colors many states
        \item They can be addressed by tuples (color level, original state number) however
        \item In spot all states are simply numbers. We construct the large automaton such that
              the state (color level i, original state number s) has the number (i * number of original states + s)
        \item Then in the ith level, copy all transitions s -> sp in the original automaton to
              to (i, s) -> (i, sp) except
        \item if the transition has the ith color, then we go to the next level (i, s) -> (i+1, sp)
              [All transitions added so far are colorless] except
        \item if i is already the last level. Then we loop back to the 0 lvl: (i, s)-> (0, sp)
              and only these transition get the (new and only) color
    \end{itemize}
\end{itemize}

\vspace{12pt}

\textcolor{blue}{prop_} \\
\textcolor[HTML]{006400}{the graph, the edge number, optimal energy is chosen or propagated (opt)}\\
\textcolor{brown}{propagates energy along the edge, returns whether destination changed or not}
\begin{itemize}
    \item e’ = calculates bounded energy min(weak upper bound, state energy + weight)
    \item if e’ is positive and higher than destination energy, updates destination energy to e’ and add the edge to optimal predecessors
    \item if e’ is positive and opt is false, update destination energy to e’ and add the edge to optimal predecessors \textcolor{red}{(just using the weights when running BF1 and using the weak upper bound when running pump)}
    \item returns true if energy destination changes, false otherwise
\end{itemize}
\pscrep{Correct in general, I'm not sure if I understand the question correctly. The upper bound is always enforced; opt only determines whether the energy is updated when smaller than before or not}

\vspace{12pt}

\textcolor{blue}{mark_}\\
\textcolor[HTML]{006400}{the graph, the state}\\
\textcolor{brown}{marks a state as waiting if it’s not already waiting and adds it to the list of waiting states}\\

\textcolor{blue}{loop_}\\
\textcolor[HTML]{006400}{the graph, the initial state}\\
\textcolor{brown}{iterates over loops starting from the initial state and returns its contents}\\
\_rotate(1) is used to bring the initial state to the start\\

\newpage

\textcolor{blue}{pumpLoop_}\\
\textcolor[HTML]{006400}{the graph, the state}\\
\textcolor{brown}{pumps a positive loop containing the state}
\begin{itemize}
    \item sets all the states’ energy on the loop to -2 \textcolor{red}{(special marker? why -2)}
    \item marks all the states with 2 (mark for an old loop)
    \item pumps the initial state with the weak upper bound
    \item sets a counter for iterations, launches loop\_ on each state until unchanged (reached the fixed point)
    \item if the counter is higher than 2, it reached the fixed point too late
\end{itemize}
\pscrep{If I'm not mistaken I use -2 because -1 is another special to mark unreachable state / states which have never been visited}
\pscrep{Yes the check for the counter being 2 or less is just a sanity check}


\vspace{12pt}

\textcolor{blue}{checkLoop}\\
\textcolor[HTML]{006400}{the graph, the state}\\
\textcolor{brown}{the state is a candidate on the loop that needs to be pumped (it’s on the loop, on its postfix, or in a loop that’s already pumped)}
\begin{itemize}
    \item marks all states on the current loop with 1 following the predecessor along the state
    \item if we fall back on a 1 it’s a loop and we pumpLoop\_
    \item if we get interrupted by a 2, the loop has already been pumped
    \item goes back to the initial state and marks all the remaining states outside of the loop (not marked by pump loop, still marked as 1 with 2 to indicate they have already been visited
\end{itemize}

\pscrep{Yes, the idea is that any state that has increased its energy on the second
iteration of BF needs to be either on a positive loop cycle or on the sufffix of a loop.
So we make sure we have a state on the loop and then pump it.
After that we can also adjust the energy of the suffix of the loop
the increase convergence speed}


\vspace{12pt}

\textcolor{blue}{pumpAll}\\
\textcolor[HTML]{006400}{the graph}\\
\textcolor{brown}{for each state:}
\begin{itemize}
    \item we check if its energy changed, if it didn’t we skip it \textcolor{red}{(changed after BF1?)}
    \item we check if it doesn’t belong to an old loop or postfix
    \item gets the predecessor, if none we’re on the initial state and the energy has to be set to -1 \textcolor{red}{(why?)}, and we skip it
    \item calculates e’, if energy can increase, checkLoop \textcolor{red}{(why not check the loop when the energy doesn’t increase, we don’t know the weights on the next nodes yet, does it matter at which state we start?)}
\end{itemize}

\pscrep{You do one BF -> energies are at a fix point EXCEPT if there are positive loops.
You save these energy lelvels. You run another round of BF. All states whose energy changed
are necessarily on or in the suffix of a positive loop.}
\pscrep{No, the if at 263 needs to be interpreted differently:

en is the edgenumber of the edge "leading to" the predescessor. If it is 0
(special marker) then no predescessor exists. If there is no predecessor, then its energy has 
to be -1 (indicating unreachable) EXCEPT if it is the initial state.}
\pscrep{For the last point: I think this way you get a state at the end of the suffix
and therefore you only need to call checkLoop once. Otherwise it can happen
that you call it for every state on the suffix one after another (It would not be
wrong but inefficient.). But it's a year since I wrote this, so I have to think about it a 
bit longer.}

\vspace{12pt}

\textcolor{blue}{BF1}\\
\textcolor[HTML]{006400}{the graph}\\
\textcolor{brown}{modified Bellman-Ford}
\begin{itemize}
    \item the main loop does N number of states iterations
    \item we pop the states that are waiting (initially the initial state is on that list), pump, then add the destination states that got modified as a result to the list of states that are waiting
\end{itemize}
\pscrep{Yes almost normal BF, only with the weak upper bound.}
\vspace{12pt}

\newpage

\textcolor{blue}{FindMaxEnergy_}\\
\textcolor[HTML]{006400}{the graph, the initial state, the weak upper bound, the initial credit}\\
\textcolor{brown}{for each state, calculates the maximum energy reached from the initial state with the initial credit}
\begin{itemize}
    \item the function modifies self.changedE_ as it’s running and updating energies
    \item saves old energy states, runs BF1, checks for changes
    \item saves old energy states, runs pumpAll, checks for changes
    \item stops when no more changes can be made
\end{itemize}

\vspace{12pt}

\textcolor{blue}{FindMaxEnergyGen}\\
\textcolor[HTML]{006400}{the graph, the initial state, the weak upper bound, the initial credit}\\
\textcolor{brown}{returns the generator resulting from the yields of the previous function}\\

\textcolor{blue}{FindMaxEnergy}\\
\textcolor[HTML]{006400}{the graph, the initial state, the weak upper bound, the initial credit}\\
\textcolor{brown}{consumes the generator and returns the last couple of (best predecessor, energy) which represents the fixed point}\\

\textcolor{blue}{BuechiEnergy}\\
\textcolor[HTML]{006400}{the automata, the initial state, the weak upper bound, the initial credit, the display mode}
\begin{enumerate}
    \item Find the maximum optimal predecessor and energy of the fixed point, with algorithm 2, run FindMaxEnergy
    \item Loop over all accepting SCCs :
    \begin{itemize}
        \item degeneralize the SCC using degenCounting (and create a reverse dictionary out of the rename() dictionary, \textcolor{red}{for optimisation purposes?})
        \item \pscrep{No, when you degeneralize the whole automaton, each lvl is a copy of the whole automaton
        and the state correspondance is easy. Here, for effiencency, we do it SCC by SCC, so we need a dict from the
        state number of state in the original SCC to the corresponding state in the first level of the 
        degeneralization as here the numbers start necessarily with 0}
        \item loop over backedges :
        \begin{itemize}
            \item start from the destination of the backedge (the start energy is the optimal energy of that destination) and find the fixed point (best predecessor and maximum energy)
            \item if said energy is positive, calculate the dest energy with respect to the weak upper bound
            \item if said energy is negative, set it to -1 \textcolor{red}{(why -1?)}
            \item if the new dest energy is higher than the old one, we found the non negative loop and we return true
            \item otherwise, we restart the whole process by replacing the state energy with the new energy, and again if dest energy is positive and  higher we found the loop, else we move on to the next edge until there are potentially none. \textcolor{red}{(why does this work?)}
        \end{itemize}
    \end{itemize}
\end{enumerate}
\pscrep{For the last points we should make a quick call, easier with drawing}
\newpage

\section{The global functioning}

\textcolor{blue}{Algorithm 2}\\
\begin{itemize}
    \item Propagates (number of state times) through the original graph using the weights on the edges
    \item For each unvisited state with changed energy, we calculate the energy by using the weights on the edges
    \item If the energy is higher, we check if there’s a loop
    \item If there’s a loop we pump the loop with the weak upper bound
    \item We do it again until there are no changes
    \item The last state is the fixed point
\end{itemize}

\vspace{12pt}

\textcolor[HTML]{006400}{Run Algorithm 2 on the original automata. Degenralize the automata’s SCCs. On each SCC, run Algorithm 2 potentially twice.}\\

\newpage

\section{The framing of the problem}

\textcolor{blue}{In the end we obtain :}\\
\begin{itemize}
    \item either False and no non-negative loop
    \item or True and the start edge of a lasso along with its non-negative loop :
    \begin{itemize}
        \item some loops on the graph would already be marked with 2 (explored), others with 0 (not explored)
        \item on the original graph, each state would have an optimal energy set by FindMaxEnergy run on the original graph
        \item the degeneralized graph could be potentially only partially set in terms of markings and energy
    \end{itemize}
\end{itemize}

\vspace{12pt}

\textcolor{blue}{To return the path :}\\
\begin{itemize}
    \item We start from the lasso, then its predecessor
    \item We continue by taking all possible entering edges
    \item If we encounter a cycle we might have to go through it more or less than once
    \item We have to keep in mind that we can't just look at the markings because there are loops that weren't visited and that are marked with 0 instead of 2
    \item \textcolor{red}{I still don’t know when to stop pursuing a possible path, even if the energy of a state is not immediately sufficient and we get a negative number when subtracting we might still restore it as we go back further}
\end{itemize}

\vspace{12pt}

\textcolor{blue}{To find another solution :}\\
\begin{itemize}
    \item Try to build the path as we go through the algorithm without consuming too much memory?
    \item Try to use the energies calculated by FindMaxEnergies?
\end{itemize}

\end{document}
